<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Planner Desktop</title>
    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Setting the body background to the absolute darkest neutral color */
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            height: 100vh;
            overflow: hidden;
            background-color: #0a0a0a;
            /* neutral-950 equivalent for absolute fallback */
        }

        #root {
            height: 100%;
        }

        /* Dark mode settings for scrollbar using neutral colors */
        .scrollbar-style::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar-style::-webkit-scrollbar-thumb {
            background-color: #525252;
            /* neutral-600 */
            border-radius: 4px;
        }

        .scrollbar-style::-webkit-scrollbar-track {
            background-color: #0a0a0a;
            /* neutral-950 */
        }

        .dark .scrollbar-style::-webkit-scrollbar-thumb {
            background-color: #404040;
            /* neutral-700 */
            border-radius: 4px;
        }

        .dark .scrollbar-style::-webkit-scrollbar-track {
            background-color: #0a0a0a;
            /* neutral-950 */
        }
    </style>
</head>

<body>
    <div id="root" class="h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, useRef } = React;

        // --- Configuration ---
        const CONFIG = {
            startHour: 8, // 8 AM
            endHour: 17,  // 5 PM
            skipHour: 12, // Skip 12 PM
            limits: {
                'must-do': 3,
                'communications': 3,
                'todo': 7
            }
        };

        // Helper function to get YYYY-MM-DD string from a Date object
        const getYYYYMMDD = (date) => date.toISOString().split('T')[0];

        // Helper function to get a date string offset by days
        const getDateOffset = (dateString, offset) => {
            const date = new Date(dateString + 'T00:00:00');
            date.setDate(date.getDate() + offset);
            return getYYYYMMDD(date);
        };

        // --- File System and Persistence Logic ---
        const isElectron = window && window.require;
        const storageKey = 'daily_planner_data_v2'; // Updated key for new data structure
        const themeKey = 'planner_theme';

        const saveDataToLocalStorage = (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (e) {
                console.error("Could not save data to localStorage", e);
            }
        };

        const loadDataFromLocalStorage = (key) => {
            try {
                const savedData = localStorage.getItem(key);
                return savedData ? JSON.parse(savedData) : null;
            } catch (e) {
                console.error("Could not load data from localStorage", e);
                return null;
            }
        };

        const saveDataToFile = (data) => {
            if (!isElectron) {
                saveDataToLocalStorage(storageKey, data);
                return;
            }
            try {
                const fs = require('fs');
                const path = require('path');
                // Use a new file name to avoid conflict with old structure data
                const savePath = path.join(require('os').homedir(), 'DailyPlannerData_v2.json');
                fs.writeFileSync(savePath, JSON.stringify(data, null, 2), 'utf-8');
                console.log('Data saved successfully to:', savePath);
            } catch (e) {
                console.error("Error saving file via Electron FS:", e);
                saveDataToLocalStorage(storageKey, data);
            }
        };

        const loadDataFromFile = () => {
            if (!isElectron) {
                return loadDataFromLocalStorage(storageKey) || { tasks: {}, days: {} };
            }
            try {
                const fs = require('fs');
                const path = require('path');
                // Use a new file name to avoid conflict with old structure data
                const loadPath = path.join(require('os').homedir(), 'DailyPlannerData_v2.json');
                if (fs.existsSync(loadPath)) {
                    const data = fs.readFileSync(loadPath, 'utf-8');
                    console.log('Data loaded successfully from:', loadPath);
                    return JSON.parse(data);
                }
                // Return initial structure if no file found
                return { tasks: {}, days: {} };
            } catch (e) {
                console.error("Error loading file via Electron FS:", e);
                return loadDataFromLocalStorage(storageKey) || { tasks: {}, days: {} };
            }
        };


        // Simplified icon components using Lucide SVGs
        const Icon = ({ name, className, onClick }) => {
            const icons = {
                Plus: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 5v14M5 12h14" /></svg>,
                Clock: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></svg>,
                Trash2: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6M10 11v6M14 11v6M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /></svg>,
                Calendar: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M8 2v4M16 2v4M21 17h-2M3 17h2M12 21v-2M12 13v-2M12 9v-2M3 8h18M3 17h18M2 17a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-9a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2z" /></svg>,
                ChevronLeft: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m15 18-6-6 6-6" /></svg>,
                ChevronRight: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m9 18 6-6-6-6" /></svg>,
                CheckSquare: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 11 12 14 22 4" /><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11" /></svg>,
                Square: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" /></svg>,
                Sun: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="4" /><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41" /></svg>,
                Moon: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 0 1 1-9-9Z" /></svg>,
                Target: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></svg>,
                Rollover: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 7.21v11.58a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7.21c0-1.13.84-2.12 1.95-2.21l.6-.05h13.25c1.11.09 1.95 1.08 1.95 2.21z" /><path d="m11.2 14.8-1.6 1.6 1.6 1.6" /><path d="M12 16.4h-.4c-1.12 0-2-.88-2-2V10c0-1.12.88-2 2-2h4" /></svg>,
                Edit: <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /></svg>
            };
            return React.cloneElement(icons[name] || <div />, { className, onClick });
        };


        // --- Standalone Task Item Component ---
        const TaskItem = ({ task, allTasks, toggleTask, deleteTask, handleDragStart, handleEditTask }) => {
            const [isEditing, setIsEditing] = useState(false);

            // Get the original task data from the global store
            const originalTask = allTasks[task.taskId];
            const [localTitle, setLocalTitle] = useState(originalTask ? originalTask.title : '');

            const inputRef = useRef(null);

            const isCompleted = originalTask ? originalTask.completed : false;

            useEffect(() => {
                if (isEditing) {
                    inputRef.current.focus();
                }
            }, [isEditing]);

            // Sync local title with global state if it changes externally
            useEffect(() => {
                if (originalTask && localTitle !== originalTask.title) {
                    setLocalTitle(originalTask.title);
                }
            }, [originalTask?.title]);


            const saveEdit = () => {
                const trimmedTitle = localTitle.trim();
                if (trimmedTitle && trimmedTitle !== (originalTask ? originalTask.title : '')) {
                    handleEditTask(task.taskId, trimmedTitle);
                }
                // Reset local state in case the new title was invalid or the same
                setLocalTitle(originalTask ? originalTask.title : task.title);
                setIsEditing(false);
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') {
                    saveEdit();
                }
                if (e.key === 'Escape') {
                    setLocalTitle(originalTask ? originalTask.title : task.title);
                    setIsEditing(false);
                }
            };

            if (!originalTask) return null; // Defensive check for missing task data

            return (
                <div
                    draggable
                    onDragStart={(e) => {
                        // Drag using the unique taskId
                        handleDragStart(e, task.taskId);
                        e.currentTarget.classList.add('opacity-50', 'shadow-xl');
                    }}
                    onDragEnd={(e) => {
                        e.currentTarget.classList.remove('opacity-50', 'shadow-xl');
                    }}
                    /* USE NEUTRAL: Task item background/border */
                    className="group flex items-center gap-2 bg-neutral-800 p-2 rounded border border-neutral-700 shadow-sm mb-2 cursor-grab active:cursor-grabbing hover:border-neutral-600 transition-colors"
                >
                    {/* USE NEUTRAL: Icons and text colors adjusted for deeper contrast against neutral-800 */}
                    {/* Toggle uses the unique taskId to update the global task object */}
                    <button onClick={() => toggleTask(task.taskId)} className="text-neutral-400 hover:text-neutral-300">
                        {isCompleted ? <Icon name="CheckSquare" className="w-5 h-5 text-neutral-400" /> : <Icon name="Square" className="w-5 h-5 text-neutral-400" />}
                    </button>

                    {isEditing ? (
                        <input
                            ref={inputRef}
                            type="text"
                            value={localTitle}
                            onChange={(e) => setLocalTitle(e.target.value)}
                            onBlur={saveEdit}
                            onKeyDown={handleKeyDown}
                            className="flex-1 text-sm p-0 bg-neutral-700 border border-neutral-600 rounded focus:ring-1 focus:ring-neutral-400 focus:border-neutral-500 focus:outline-none text-neutral-100"
                        />
                    ) : (
                        // Display the title from the global task object
                        <span
                            className={`flex-1 text-sm cursor-text ${isCompleted ? 'line-through text-neutral-500' : 'text-neutral-100'}`}
                            onDoubleClick={() => {
                                if (!isCompleted) setIsEditing(true);
                            }}
                        >
                            {originalTask.title}
                        </span>
                    )}

                    {task.rolledOverFrom && (
                        <span
                            className="text-xs text-yellow-500 font-semibold italic bg-neutral-700 px-2 py-0.5 rounded-full whitespace-nowrap"
                            title={`Originally created on ${task.rolledOverFrom}`}
                        >
                            <Icon name="Rollover" className="w-3 h-3 inline mr-1" />
                            Rolled Over
                        </span>
                    )}

                    {/* Delete uses the unique taskId to update the global task object and the day list */}
                    <button onClick={() => deleteTask(task.taskId)} className="opacity-0 group-hover:opacity-100 text-neutral-400 hover:text-red-400 transition-colors">
                        <Icon name="Trash2" className="w-4 h-4" />
                    </button>
                </div>
            );
        };

        // --- Standalone Column Component with Local State Fix and Drag Feedback ---
        const Column = ({ title, category, limit, tasks, allTasks, handleAddTask, handleDrop, handleDragStart, toggleTask, deleteTask, handleEditTask }) => {
            const [localNewTaskTitle, setLocalNewTaskTitle] = useState('');
            const [isDragOver, setIsDragOver] = useState(false);

            // FIX: Filter out tasks that are completed AND/OR don't belong to this category 
            // to get the count of INCOMPLETE tasks for this specific column.
            const visibleTasks = tasks.filter(t => {
                const globalTask = allTasks[t.taskId];
                // CRITICAL FIX: Ensure the task belongs to this category AND is incomplete.
                // Uses GLOBAL category if available (fixing sync issues), falls back to entry data.
                const categoryMatch = (globalTask?.category || t.category) === category;
                return globalTask && !globalTask.completed && categoryMatch;
            });

            const isLimitReached = limit && visibleTasks.length >= limit;

            const addNewTask = () => {
                if (!localNewTaskTitle.trim()) return;
                // handleAddTask performs the limit check using the correct filtering logic
                handleAddTask(category, localNewTaskTitle.trim());
                setLocalNewTaskTitle('');
            };

            const handleDragEnter = (e) => {
                e.preventDefault();
                setIsDragOver(true);
            };

            const handleDragLeave = (e) => {
                const targetElement = e.currentTarget;
                const relatedElement = e.relatedTarget;
                if (relatedElement && targetElement.contains(relatedElement)) return;
                setIsDragOver(false);
            };

            const handleColumnDrop = (e) => {
                setIsDragOver(false);
                handleDrop(e, category);
            };

            return (
                <div
                    className={`flex-1 min-w-[200px] flex flex-col h-full rounded-xl border-dashed transition-all duration-150
                        ${isDragOver
                            /* USE NEUTRAL: Darker drag over feedback */
                            ? 'bg-neutral-800 border-neutral-600 border-4 shadow-lg'
                            /* USE NEUTRAL: Set default column background to neutral-900 (from parent) and darker border */
                            : 'bg-neutral-50/50 border-neutral-200 border-2 dark:bg-neutral-900/50 dark:border-neutral-800'
                        }`}
                    onDragOver={(e) => e.preventDefault()}
                    onDragEnter={handleDragEnter}
                    onDragLeave={handleDragLeave}
                    onDrop={handleColumnDrop}
                >
                    {/* USE NEUTRAL: Darken header border */}
                    <div className="p-3 border-b border-neutral-800 flex justify-between items-center">
                        <h3 className="font-semibold text-neutral-700 dark:text-neutral-100 text-sm">{title}</h3>
                        <span className="text-xs text-neutral-400">{limit} max</span>
                    </div>

                    <div className="p-3 flex-1 overflow-y-auto scrollbar-style">
                        {/* Only map over visible (incomplete and correctly categorized) tasks */}
                        {visibleTasks.map(task =>
                            <TaskItem
                                key={task.taskId} // Use taskId as key for consistency
                                task={task}
                                allTasks={allTasks}
                                toggleTask={toggleTask}
                                deleteTask={deleteTask}
                                handleDragStart={handleDragStart}
                                handleEditTask={handleEditTask}
                            />)}

                        {/* Inline Add Task Input */}
                        <div className="mt-2 flex gap-2">
                            <input
                                type="text"
                                placeholder={isLimitReached ? `Limit Reached (${limit})` : "+ Add item"}
                                disabled={isLimitReached}
                                className={`
                                    w-full text-sm px-2 py-1 
                                    /* USE NEUTRAL: Input background to neutral-800, border to neutral-700 */
                                    bg-neutral-50 dark:bg-neutral-800 border-b border-neutral-700 dark:border-neutral-700 
                                    focus:bg-white dark:focus:bg-neutral-900 focus:border-neutral-600 focus:ring-neutral-600 focus:ring-1 
                                    rounded-t-md transition-all duration-150 focus:outline-none
                                    placeholder-neutral-400 dark:placeholder-neutral-500 text-neutral-800 dark:text-neutral-100
                                    ${isLimitReached ? 'text-neutral-400 cursor-not-allowed' : ''}
                                `}
                                value={localNewTaskTitle}
                                onChange={(e) => setLocalNewTaskTitle(e.target.value)}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                        addNewTask();
                                    }
                                }}
                            />
                        </div>
                    </div>
                </div>
            );
        };


        // --- Main DailyPlanner Component ---
        const DailyPlanner = () => {

            // Pre-calculate today's date string for comparison
            const todayDateString = useMemo(() => getYYYYMMDD(new Date()), []);
            const todayRef = useRef(todayDateString); // Use ref to keep today's date stable for comparisons

            // --- State ---
            const [currentDate, setCurrentDate] = useState(todayDateString);
            const [store, setStore] = useState(() => loadDataFromFile());
            const [currentTimePercentage, setCurrentTimePercentage] = useState(-1);
            const [hoveredSlotId, setHoveredSlotId] = useState(null);
            const [isDarkMode, setIsDarkMode] = useState(() => loadDataFromLocalStorage(themeKey) === 'dark');

            const allTasks = store.tasks;

            // --- Derived State ---
            const getDayData = useCallback((date) => store.days[date] || {
                taskEntries: [], // NEW: Stores list of { taskId, category, slotId, rolledOverFrom }
                gratefulness: '',
                reflections: '',
                rolloverComplete: false
            }, [store.days]);

            const currentDayData = getDayData(currentDate);
            const isToday = currentDate === todayRef.current; // Use ref for stable comparison

            // Helper to get task entries for a category, filtered by global completion status
            const getCategoryTasks = (category) => {
                return currentDayData.taskEntries.filter(t => {
                    const globalTask = allTasks[t.taskId];
                    // Defensive check: Only include if the global task exists and is not completed
                    return globalTask && t.category === category && !globalTask.completed;
                });
            };


            // --- Task Rollover Logic (FIXED: Continuous & Auto-Correcting) ---
            useEffect(() => {
                // This effect should run whenever the date changes
                const dayData = getDayData(currentDate);
                const prevDateString = getDateOffset(currentDate, -1);
                const prevDayData = getDayData(prevDateString);

                // Check if the previous day is in the store and has tasks (or was visited)
                const previousDayExists = prevDayData && (prevDayData.taskEntries.length > 0 || prevDayData.rolloverComplete);

                // Rollover needs to run if previous day data exists. 
                // Removed the !dayData.rolloverComplete check to allow "catching up" if previous day changes later.
                if (previousDayExists) {

                    // 1. Identify tasks from the previous day that need to be rolled over
                    const tasksToRollover = prevDayData.taskEntries.filter(entry => {
                        const task = allTasks[entry.taskId];
                        // Only roll over incomplete tasks. Check GLOBAL category to exclude scheduled items if needed.
                        // Assuming 'scheduled' items (time slots) shouldn't roll over as "to-dos".
                        const category = task.category || entry.category;
                        return task && !task.completed && category !== 'scheduled';
                    }).map(entry => ({
                        taskId: entry.taskId,
                        // category: entry.category, // Remove redundant local category on rollover
                        slotId: null, // Reset scheduled time
                        rolledOverFrom: prevDateString, // Flag
                        // Fallback category from entry if not global yet (will be synced later)
                        _fallbackCategory: entry.category
                    }));

                    // 2. Clear completed tasks from the *current* day's list that were rolled over
                    const tasksToKeep = dayData.taskEntries.filter(entry => {
                        const task = allTasks[entry.taskId];
                        // Keep if it's an uncompleted task OR it was originally created on this day (rolledOverFrom is falsy)
                        return task && (!task.completed || !entry.rolledOverFrom);
                    });

                    // 3. Merge: Tasks to keep + Tasks to rollover (excluding duplicates)
                    const existingTaskIds = new Set(tasksToKeep.map(t => t.taskId));
                    const newEntries = [
                        ...tasksToKeep,
                        ...tasksToRollover.filter(t => !existingTaskIds.has(t.taskId))
                    ].map(entry => ({
                        ...entry,
                        // Ensure the entry has a category helper if needed, but we prefer global lookup now.
                        // We keep local 'category' for 'scheduled' slots or legacy support.
                        category: entry.category || entry._fallbackCategory
                    }));

                    // Check if anything actually changed to avoid infinite loops
                    const currentIds = dayData.taskEntries.map(t => t.taskId).sort().join(',');
                    const newIds = newEntries.map(t => t.taskId).sort().join(',');

                    if (currentIds !== newIds || !dayData.rolloverComplete) {

                        setStore(prev => ({
                            ...prev,
                            days: {
                                ...prev.days,
                                [currentDate]: {
                                    ...dayData,
                                    taskEntries: newEntries,
                                    rolloverComplete: true, // Mark rollover as complete for this day
                                }
                            }
                        }));

                        console.log(`Rollover: Updated tasks for ${currentDate}`);
                    }
                }
            }, [currentDate, getDayData, allTasks]); // Re-run when date changes or global tasks/days change

            // --- Persistence Effects ---
            // Save store data on change (local/file system)
            useEffect(() => {
                saveDataToFile(store);
            }, [store]);

            // Save theme preference
            useEffect(() => {
                saveDataToLocalStorage(themeKey, isDarkMode ? 'dark' : 'light');
                document.documentElement.classList.toggle('dark', isDarkMode);
            }, [isDarkMode]);

            const toggleTheme = () => {
                setIsDarkMode(prev => !prev);
            };

            // --- Time Logic ---
            const workHours = [];
            for (let h = CONFIG.startHour; h <= CONFIG.endHour; h++) {
                if (h !== CONFIG.skipHour) workHours.push(h);
            }
            // The total time span from 8:00 AM to the end of the 5 PM hour (17:59) minus the skip hour (12 PM)
            const workWindowDurationMinutes = useMemo(() => {
                // Total hours spanned (8 AM to 6 PM) is (17 - 8 + 1) = 10 hours = 600 minutes
                let minutes = (CONFIG.endHour - CONFIG.startHour + 1) * 60;

                // Subtract 1 hour (60 minutes) for the skipped hour (12 PM)
                if (CONFIG.skipHour >= CONFIG.startHour && CONFIG.skipHour <= CONFIG.endHour) {
                    minutes -= 60;
                }
                return minutes; // This should be 540 minutes (9 hours of visibility span)
            }, [CONFIG.startHour, CONFIG.endHour, CONFIG.skipHour]);


            useEffect(() => {
                const updateLinePosition = () => {
                    const now = new Date();
                    const currentHour = now.getHours();
                    const currentMin = now.getMinutes();

                    if (!isToday || currentHour < CONFIG.startHour || currentHour > CONFIG.endHour) {
                        setCurrentTimePercentage(-1);
                        return;
                    }

                    // Check if current time falls in the skipped hour (12 PM)
                    if (currentHour === CONFIG.skipHour) {
                        setCurrentTimePercentage(-1); // Hide line during lunch
                        console.log("Time Line Debug: Hiding line. Currently in skipped hour (12 PM).");
                        return;
                    }

                    // Calculate elapsed minutes from the start of the work day (CONFIG.startHour)
                    let elapsedMinutes = (currentHour - CONFIG.startHour) * 60 + currentMin;

                    // Subtract the skipped hour duration if we are past it
                    if (currentHour > CONFIG.skipHour) {
                        elapsedMinutes -= 60;
                    }

                    // Calculate percentage relative to the total work window duration
                    const position = (elapsedMinutes / workWindowDurationMinutes) * 100;

                    console.log(`Time Line Debug: Time: ${currentHour}:${currentMin}, Elapsed: ${elapsedMinutes}min, Total Span: ${workWindowDurationMinutes}min, Position: ${position.toFixed(2)}%`);


                    setCurrentTimePercentage(Math.max(0, Math.min(100, position)));
                };

                updateLinePosition();
                const interval = setInterval(updateLinePosition, 60000); // Check every minute
                return () => clearInterval(interval);
            }, [isToday, workWindowDurationMinutes]);

            // --- Handlers ---

            const handleDateChange = (offset) => {
                setCurrentDate(getDateOffset(currentDate, offset));
            };

            const jumpToToday = () => {
                setCurrentDate(todayRef.current);
            };

            const updateDayData = (updates) => {
                setStore(prev => ({
                    ...prev,
                    days: {
                        ...prev.days,
                        [currentDate]: { ...getDayData(currentDate), ...updates }
                    }
                }));
            };

            // NEW HANDLER: Update task details in the global store
            const updateTaskInStore = (taskId, updates) => {
                setStore(prev => ({
                    ...prev,
                    tasks: {
                        ...prev.tasks,
                        [taskId]: {
                            ...(prev.tasks[taskId] || {}),
                            ...updates
                        }
                    }
                }));
            };

            // MODIFIED: Adds a task to the global store and to the current day's entries
            const handleAddTask = (category, title) => {

                // --- CORRECTED LIMIT CHECK ---
                // Calculate the count based on INCOMPLETE tasks for the current day/category
                const currentCount = currentDayData.taskEntries.filter(t => {
                    const globalTask = allTasks[t.taskId];
                    return globalTask && !globalTask.completed && t.category === category;
                }).length;

                if (CONFIG.limits[category] && currentCount >= CONFIG.limits[category]) {
                    console.error(`Limit reached for ${category}`);
                    return;
                }
                // -----------------------------

                const newTaskId = Date.now().toString();

                const newTaskGlobal = {
                    title: title,
                    createdOn: currentDate,
                    completed: false,
                    category: category, // NEW Task Property: Global Category
                };

                const newDayEntry = {
                    taskId: newTaskId,
                    category: category, // This ensures it is only associated with the correct column
                    slotId: null,
                    rolledOverFrom: null, // New tasks are not rolled over
                };

                // 1. Update the global tasks list
                setStore(prev => ({
                    ...prev,
                    tasks: {
                        ...prev.tasks,
                        [newTaskId]: newTaskGlobal
                    },
                    // 2. Update the current day's list of entries
                    days: {
                        ...prev.days,
                        [currentDate]: {
                            ...currentDayData,
                            taskEntries: [...currentDayData.taskEntries, newDayEntry]
                        }
                    }
                }));
            };

            // MODIFIED: Toggles completion status in the global task store
            const toggleTask = (taskId) => {
                const task = allTasks[taskId];
                if (!task) return;

                // Update the task's completed status in the global store
                updateTaskInStore(taskId, { completed: !task.completed });
            };

            // MODIFIED: Deletes a task from the global store AND the current day's entries
            const deleteTask = (taskId) => {

                // 1. Remove the task from the global store
                setStore(prev => {
                    const { [taskId]: _, ...restTasks } = prev.tasks;
                    return {
                        ...prev,
                        tasks: restTasks,
                        days: Object.entries(prev.days).reduce((acc, [date, day]) => {
                            // 2. Remove the task from ALL day entries (prevents future rollovers)
                            acc[date] = {
                                ...day,
                                taskEntries: day.taskEntries.filter(t => t.taskId !== taskId)
                            };
                            return acc;
                        }, {})
                    };
                });
            };

            // MODIFIED: Edit Task title in the global store
            const handleEditTask = (taskId, newTitle) => {
                updateTaskInStore(taskId, { title: newTitle });
            };


            // MODIFIED: Drag uses taskId
            const handleDragStart = (e, taskId) => {
                e.dataTransfer.setData('taskId', taskId);
            };

            // MODIFIED: Drop updates the current day's entries
            const handleDrop = (e, targetCategory, slotId = null) => {
                e.preventDefault();
                const taskId = e.dataTransfer.getData('taskId');

                setHoveredSlotId(null);

                const taskEntryIndex = currentDayData.taskEntries.findIndex(t => t.taskId === taskId);
                const taskEntry = currentDayData.taskEntries[taskEntryIndex];
                if (!taskEntry) return;

                // Limit check when dropping into a non-scheduled, limited category
                if (targetCategory !== 'scheduled' && targetCategory !== taskEntry.category) {

                    // Correct limit check: only count INCOMPLETE tasks in the target category
                    const currentCount = currentDayData.taskEntries.filter(t => {
                        const globalTask = allTasks[t.taskId];
                        return globalTask && !globalTask.completed && t.category === targetCategory;
                    }).length;

                    if (CONFIG.limits[targetCategory] && currentCount >= CONFIG.limits[targetCategory]) {
                        console.error(`Limit reached for ${targetCategory}`);
                        return;
                    }
                }

                // Update the category in GLOBAL TASK store if it's a category move (not just time slot)
                if (targetCategory !== 'scheduled') {
                    updateTaskInStore(taskId, { category: targetCategory });
                }

                const updatedEntries = [...currentDayData.taskEntries];
                if (taskEntryIndex !== -1) {
                    updatedEntries[taskEntryIndex] = {
                        ...taskEntry,
                        category: targetCategory,
                        slotId: targetCategory === 'scheduled' ? slotId : null,
                        // Clear rolledOverFrom if manually moved by user
                        rolledOverFrom: taskEntry.rolledOverFrom && targetCategory === 'scheduled' ? null : taskEntry.rolledOverFrom
                    };
                }

                updateDayData({ taskEntries: updatedEntries });
            };

            // Drag handlers for the time slots (No change needed)
            const handleSlotDragEnter = (slotId) => (e) => {
                e.preventDefault();
                setHoveredSlotId(slotId);
            };
            const handleSlotDragLeave = (e) => {
                const targetElement = e.currentTarget;
                const relatedElement = e.relatedTarget;
                if (relatedElement && targetElement.contains(relatedElement)) return;
                setHoveredSlotId(null);
            };
            const handleSlotDrop = (slotId) => (e) => {
                handleDrop(e, 'scheduled', slotId);
            };


            return (
                // Theme wrapper: applies 'dark' class to the entire container
                <div className={`flex flex-col h-full ${isDarkMode ? 'dark' : ''}`}>
                    {/* USE NEUTRAL: Use neutral-950 for the absolute darkest background */}
                    <div className="flex flex-col h-full bg-neutral-950 dark:bg-neutral-950 text-neutral-800 dark:text-neutral-100 font-sans overflow-hidden">

                        {/* --- Header & Date Nav --- */}
                        {/* USE NEUTRAL: Use neutral-900 for the header, neutral-800 for border */}
                        <div className="h-16 bg-neutral-900 dark:bg-neutral-900 border-b border-neutral-800 flex items-center justify-between px-6 shadow-xl z-20">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold text-neutral-100 flex items-center gap-2">
                                    <Icon name="Calendar" className="w-5 h-5 text-neutral-500" />
                                    Daily Planner
                                </h1>
                                {/* USE NEUTRAL: Use neutral-800 for date selector background, neutral-700 for hover */}
                                <div className="flex items-center bg-neutral-800 rounded-lg p-1">
                                    <button onClick={() => handleDateChange(-1)} className="p-1 hover:bg-neutral-700 rounded shadow-sm transition"><Icon name="ChevronLeft" className="w-4 h-4 text-neutral-200" /></button>
                                    <input
                                        type="date"
                                        value={currentDate}
                                        onChange={(e) => setCurrentDate(e.target.value)}
                                        className="bg-transparent border-none text-sm font-medium px-4 py-1 focus:ring-0 cursor-pointer text-neutral-200"
                                    />
                                    <button onClick={() => handleDateChange(1)} className="p-1 hover:bg-neutral-700 rounded shadow-sm transition"><Icon name="ChevronRight" className="w-4 h-4 text-neutral-200" /></button>
                                </div>
                                {/* USE NEUTRAL: Use neutral-800 for today button default, neutral-700 for hover */}
                                <button
                                    onClick={jumpToToday}
                                    disabled={isToday}
                                    className={`
                                        flex items-center gap-1 px-3 py-1 text-xs font-medium rounded-lg shadow-md transition-colors
                                        ${isToday
                                            ? 'bg-neutral-700 text-neutral-500 cursor-not-allowed'
                                            : 'bg-neutral-800 text-white hover:bg-neutral-700'
                                        }`}
                                    title="Jump to Today"
                                >
                                    <Icon name="Target" className="w-4 h-4" />
                                    Today
                                </button>
                            </div>
                            <div className="flex items-center gap-4">
                                {/* USE NEUTRAL: Use neutral-800 for theme button hover background */}
                                <button
                                    onClick={toggleTheme}
                                    className="p-2 rounded-full text-neutral-400 hover:text-neutral-200 hover:bg-neutral-800 transition"
                                    title={isDarkMode ? "Switch to Light Mode" : "Switch to Dark Mode"}
                                >
                                    <Icon name={isDarkMode ? "Sun" : "Moon"} className="w-5 h-5" />
                                </button>
                                <span className="text-sm text-neutral-400 flex items-center gap-2">
                                    {isToday ? 'Today' : 'Viewing Past/Future Day'}
                                    {/* USE NEUTRAL: Use neutral-950 for badge for maximum contrast */}
                                    <span className="ml-2 px-2 py-1 bg-neutral-950 text-neutral-300 rounded-full text-xs">
                                        {getCategoryTasks('must-do').length + getCategoryTasks('communications').length + getCategoryTasks('todo').length} incomplete tasks
                                    </span>
                                </span>
                            </div>
                        </div>

                        {/* --- Main Content Area --- */}
                        <div className="flex-1 flex overflow-hidden p-6 gap-6">

                            {/* LEFT SECTION (Columns) */}
                            <div className="flex-[3] flex flex-col gap-6">
                                {/* USE NEUTRAL: Column containers use bg-neutral-900 (darker card base) and border-neutral-800 */}
                                <div className="flex-[2] flex gap-6 min-h-0">
                                    <div className="flex-1 bg-neutral-900 rounded-xl shadow-lg border border-neutral-800 overflow-hidden">
                                        <Column
                                            title="Must-Do's"
                                            category="must-do"
                                            limit={CONFIG.limits['must-do']}
                                            tasks={currentDayData.taskEntries} // Pass ALL entries
                                            allTasks={allTasks}
                                            handleAddTask={handleAddTask}
                                            handleDrop={handleDrop}
                                            handleDragStart={handleDragStart}
                                            toggleTask={toggleTask}
                                            deleteTask={deleteTask}
                                            handleEditTask={handleEditTask}
                                        />
                                    </div>
                                    <div className="flex-1 bg-neutral-900 rounded-xl shadow-lg border border-neutral-800 overflow-hidden">
                                        <Column
                                            title="Communications"
                                            category="communications"
                                            limit={CONFIG.limits['communications']}
                                            tasks={currentDayData.taskEntries} // Pass ALL entries
                                            allTasks={allTasks}
                                            handleAddTask={handleAddTask}
                                            handleDrop={handleDrop}
                                            handleDragStart={handleDragStart}
                                            toggleTask={toggleTask}
                                            deleteTask={deleteTask}
                                            handleEditTask={handleEditTask}
                                        />
                                    </div>
                                </div>

                                <div className="flex-[3] bg-neutral-900 rounded-xl shadow-lg border border-neutral-800 overflow-hidden min-h-0">
                                    <Column
                                        title="To-Do's"
                                        category="todo"
                                        limit={CONFIG.limits['todo']}
                                        tasks={currentDayData.taskEntries} // Pass ALL entries
                                        allTasks={allTasks}
                                        handleAddTask={handleAddTask}
                                        handleDrop={handleDrop}
                                        handleDragStart={handleDragStart}
                                        toggleTask={toggleTask}
                                        deleteTask={deleteTask}
                                        handleEditTask={handleEditTask}
                                    />
                                </div>

                                {/* USE NEUTRAL: Text area containers use bg-neutral-900 and border-neutral-800 */}
                                <div className="flex-[2] flex gap-6 min-h-0">
                                    <div className="flex-1 bg-neutral-900 rounded-xl shadow-lg border border-neutral-800 p-4 flex flex-col">
                                        <h3 className="text-xs font-bold text-neutral-500 uppercase tracking-wider mb-2">Gratefulness</h3>
                                        {/* USE NEUTRAL: Textarea internal background to neutral-800 */}
                                        <textarea
                                            className="flex-1 w-full resize-none text-sm border border-neutral-700 rounded-lg shadow-sm p-3 bg-neutral-800 text-neutral-100 transition-all duration-200 focus:ring-2 focus:ring-neutral-400 focus:border-neutral-500 focus:shadow-md focus:outline-none"
                                            placeholder="I am grateful for..."
                                            value={currentDayData.gratefulness}
                                            onChange={(e) => updateDayData({ gratefulness: e.target.value })}
                                        />
                                    </div>
                                    <div className="flex-1 bg-neutral-900 rounded-xl shadow-lg border border-neutral-800 p-4 flex flex-col">
                                        <h3 className="text-xs font-bold text-neutral-500 uppercase tracking-wider mb-2">Reflections</h3>
                                        {/* USE NEUTRAL: Textarea internal background to neutral-800 */}
                                        <textarea
                                            className="flex-1 w-full resize-none text-sm border border-neutral-700 rounded-lg shadow-sm p-3 bg-neutral-800 text-neutral-100 transition-all duration-200 focus:ring-2 focus:ring-neutral-400 focus:border-neutral-500 focus:shadow-md focus:outline-none"
                                            placeholder="Today I learned..."
                                            value={currentDayData.reflections}
                                            onChange={(e) => updateDayData({ reflections: e.target.value })}
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* RIGHT SECTION (Work Blocks) */}
                            {/* USE NEUTRAL: Work Blocks container to bg-neutral-900 and border-neutral-800 */}
                            <div className="flex-[2] bg-neutral-900 rounded-xl shadow-lg border border-neutral-800 flex flex-col overflow-hidden">
                                {/* USE NEUTRAL: Work Blocks header to bg-neutral-800/50 and border-neutral-800 */}
                                <div className="p-4 border-b border-neutral-800 flex justify-between items-center bg-neutral-800/50">
                                    <h3 className="font-bold text-neutral-100">Work Blocks</h3>
                                    <span className="text-xs text-neutral-400">Skip 12 PM</span>
                                </div>

                                <div className="flex-1 overflow-y-auto relative scrollbar-style">
                                    {/* Red Current Time Line */}
                                    {currentTimePercentage >= 0 && currentTimePercentage <= 100 && isToday && (
                                        <div
                                            className="absolute left-0 right-0 z-20 pointer-events-none flex items-center"
                                            style={{ top: `${currentTimePercentage}%` }}
                                        >
                                            <div className="w-full h-[2px] bg-red-500 shadow-sm relative">
                                                <div className="absolute left-0 -top-1 w-2 h-2 bg-red-500 rounded-full"></div>
                                            </div>
                                        </div>
                                    )}

                                    {/* Time Slots */}
                                    {workHours.map((hour, index) => {
                                        const slotId = `${hour}:00`;
                                        const displayTime = hour > 12 ? `${hour - 12} PM` : `${hour} ${hour === 12 ? 'PM' : 'AM'}`;

                                        // Filter tasks by slot and completion status
                                        const slotTasks = currentDayData.taskEntries.filter(t =>
                                            t.category === 'scheduled' && t.slotId === slotId
                                        );

                                        return (
                                            <div
                                                key={hour}
                                                className="flex border-b border-neutral-800 min-h-[80px]"
                                                onDragOver={(e) => e.preventDefault()}
                                                onDragEnter={handleSlotDragEnter(slotId)}
                                                onDragLeave={handleSlotDragLeave}
                                                onDrop={handleSlotDrop(slotId)}
                                            >
                                                {/* USE NEUTRAL: Time Label column to neutral-800/50 and border-neutral-800 */}
                                                <div className="w-16 p-3 text-right text-xs font-medium text-neutral-400 border-r border-neutral-800 bg-neutral-800/50">
                                                    {displayTime}
                                                </div>
                                                <div className={`flex-1 p-2 relative transition-colors duration-150 
                                                    ${hoveredSlotId === slotId
                                                        /* USE NEUTRAL: Drag hover to neutral-800 with neutral-600 border */
                                                        ? 'bg-neutral-800 border-4 border-neutral-600'
                                                        /* USE NEUTRAL: Slot background to neutral-900 and hover to neutral-800/50 */
                                                        : 'bg-neutral-900 hover:bg-neutral-800/50'
                                                    }`}
                                                >
                                                    {/* Only show incomplete tasks in the slot block */}
                                                    {slotTasks.map(task =>
                                                        <TaskItem
                                                            key={task.taskId} // Use taskId as key for consistency
                                                            task={task}
                                                            allTasks={allTasks}
                                                            toggleTask={toggleTask}
                                                            deleteTask={deleteTask}
                                                            handleDragStart={handleDragStart}
                                                            handleEditTask={handleEditTask}
                                                        />)}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            );
        };

        // Render the component to the root element
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<DailyPlanner />);
    </script>
</body>

</html>